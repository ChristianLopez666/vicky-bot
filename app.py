# app.py ‚Äî Vicky SECOM (Versi√≥n 100% Funcional)
# Correcciones: Conexi√≥n real con Drive + GPT integrado

from __future__ import annotations

import os
import io
import re
import json
import time
import logging
import threading
from datetime import datetime
from typing import Any, Dict, Optional, List

import requests
from flask import Flask, request, jsonify
from dotenv import load_dotenv

# ==========================
# Configuraci√≥n inicial
# ==========================
load_dotenv()

META_TOKEN = os.getenv("META_TOKEN")
WABA_PHONE_ID = os.getenv("WABA_PHONE_ID")
VERIFY_TOKEN = os.getenv("VERIFY_TOKEN")
ADVISOR_NUMBER = os.getenv("ADVISOR_NUMBER", "5216682478005")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
GOOGLE_CREDENTIALS_JSON = os.getenv("GOOGLE_CREDENTIALS_JSON")

# Configuraci√≥n de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger("vicky-secom")

app = Flask(__name__)
user_state: Dict[str, str] = {}
user_data: Dict[str, Dict[str, Any]] = {}

# ==========================
# Google Drive Service - CONEXI√ìN REAL
# ==========================
def get_drive_service():
    """Inicializa el servicio de Google Drive"""
    try:
        from google.oauth2 import service_account
        from googleapiclient.discovery import build
        
        if not GOOGLE_CREDENTIALS_JSON:
            log.error("‚ùå GOOGLE_CREDENTIALS_JSON no configurado")
            return None
            
        creds_info = json.loads(GOOGLE_CREDENTIALS_JSON)
        credentials = service_account.Credentials.from_service_account_info(
            creds_info,
            scopes=['https://www.googleapis.com/auth/drive.readonly']
        )
        
        drive_service = build('drive', 'v3', credentials=credentials)
        log.info("‚úÖ Google Drive service inicializado correctamente")
        return drive_service
        
    except Exception as e:
        log.error(f"‚ùå Error inicializando Google Drive: {str(e)}")
        return None

# ==========================
# OpenAI Client - CONEXI√ìN REAL
# ==========================
def get_openai_client():
    """Inicializa el cliente de OpenAI"""
    try:
        from openai import OpenAI
        
        if not OPENAI_API_KEY:
            log.error("‚ùå OPENAI_API_KEY no configurado")
            return None
            
        client = OpenAI(api_key=OPENAI_API_KEY)
        log.info("‚úÖ OpenAI client inicializado correctamente")
        return client
        
    except Exception as e:
        log.error(f"‚ùå Error inicializando OpenAI: {str(e)}")
        return None

# ==========================
# RAG System - FUNCIONAL REAL
# ==========================
class DriveRAGSystem:
    def __init__(self):
        self.drive_service = get_drive_service()
        self.openai_client = get_openai_client()
        self.manual_content = ""
        self.last_update = None
        
    def load_manuals_from_drive(self, folder_name="Manuales Vicky"):
        """Carga manuales REALES desde Google Drive"""
        if not self.drive_service:
            log.error("‚ùå No hay servicio de Drive disponible")
            return False
            
        try:
            # Buscar la carpeta de manuales
            folder_query = f"name='{folder_name}' and mimeType='application/vnd.google-apps.folder' and trashed=false"
            folders = self.drive_service.files().list(q=folder_query, fields="files(id, name)").execute()
            
            if not folders.get('files'):
                log.warning(f"‚ö†Ô∏è No se encontr√≥ la carpeta '{folder_name}'")
                return False
                
            folder_id = folders['files'][0]['id']
            log.info(f"üìÅ Carpeta encontrada: {folder_name} (ID: {folder_id})")
            
            # Buscar archivos en la carpeta
            files_query = f"'{folder_id}' in parents and trashed=false"
            files = self.drive_service.files().list(q=files_query, fields="files(id, name, mimeType)").execute()
            
            all_content = []
            for file in files.get('files', []):
                file_id = file['id']
                file_name = file['name']
                mime_type = file['mimeType']
                
                log.info(f"üìñ Procesando archivo: {file_name}")
                
                try:
                    if mime_type == 'application/vnd.google-apps.document':
                        # Exportar Google Doc como texto
                        content = self.drive_service.files().export_media(fileId=file_id, mimeType='text/plain').execute()
                        text_content = content.decode('utf-8')
                        all_content.append(f"--- {file_name} ---\n{text_content}")
                        
                    elif mime_type == 'application/pdf':
                        # Descargar PDF
                        content = self.drive_service.files().get_media(fileId=file_id).execute()
                        
                        # Intentar extraer texto del PDF
                        try:
                            from PyPDF2 import PdfReader
                            pdf_file = io.BytesIO(content)
                            reader = PdfReader(pdf_file)
                            text_content = ""
                            for page in reader.pages:
                                text_content += page.extract_text() + "\n"
                            all_content.append(f"--- {file_name} ---\n{text_content}")
                        except Exception as e:
                            log.warning(f"‚ö†Ô∏è No se pudo extraer texto del PDF {file_name}: {str(e)}")
                            all_content.append(f"--- {file_name} ---\n[Archivo PDF - contenido no extra√≠ble]")
                    
                    else:
                        log.warning(f"‚ö†Ô∏è Tipo de archivo no soportado: {mime_type}")
                        
                except Exception as e:
                    log.error(f"‚ùå Error procesando {file_name}: {str(e)}")
                    continue
            
            self.manual_content = "\n\n".join(all_content)
            self.last_update = datetime.now()
            
            if self.manual_content:
                log.info(f"‚úÖ Manuales cargados: {len(all_content)} archivos, {len(self.manual_content)} caracteres")
                return True
            else:
                log.warning("‚ö†Ô∏è No se pudo cargar contenido de los manuales")
                return False
                
        except Exception as e:
            log.error(f"‚ùå Error cargando manuales: {str(e)}")
            return False
    
    def get_insurance_info(self, query: str) -> str:
        """Obtiene informaci√≥n sobre seguros usando GPT + manuales"""
        # Primero, asegurarse de tener contenido actualizado
        if not self.manual_content or not self.last_update or (datetime.now() - self.last_update).seconds > 3600:
            log.info("üîÑ Actualizando contenido de manuales...")
            self.load_manuals_from_drive()
        
        # Si no hay contenido de manuales, usar conocimiento base
        if not self.manual_content:
            base_knowledge = """
            INFORMACI√ìN BASE SOBRE SEGUROS DE AUTO:

            P√ìLIZA AMPLIA (Cobertura Extensa):
            - Da√±os materiales a tu auto por accidente
            - Robo total del veh√≠culo
            - Responsabilidad civil a terceros
            - Gastos m√©dicos a ocupantes
            - Asistencia vial y legal
            - Cristales y espejos
            - Equipo especial

            P√ìLIZA LIMITADA (Cobertura B√°sica):
            - Responsabilidad civil a terceros
            - Gastos m√©dicos a ocupantes
            - NO incluye da√±os a tu propio veh√≠culo

            P√ìLIZA AMPLIA PLUS:
            - Todo lo de p√≥liza amplia M√ÅS:
            - Auto sustituto
            - Cobertura en el extranjero
            - Deducible cero en primer incidente
            - Asistencia VIP

            DIFERENCIAS PRINCIPALES:
            - Amplia: Protege tu auto y a terceros
            - Limitada: Solo protege a terceros
            - Amplia Plus: Cobertura premium con beneficios adicionales

            DOCUMENTOS PARA COTIZACI√ìN:
            - INE (identificaci√≥n)
            - Tarjeta de circulaci√≥n
            - N√∫mero de placas
            """
            context = base_knowledge
        else:
            context = self.manual_content
        
        # Usar OpenAI para generar respuesta contextual
        if self.openai_client:
            try:
                response = self.openai_client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[
                        {
                            "role": "system", 
                            "content": """Eres Vicky, experta en seguros de auto. Responde de manera clara y profesional en espa√±ol. 
                            Si la informaci√≥n no est√° en el contexto, usa tu conocimiento general de seguros.
                            Incluye emojis relevantes y s√© amable."""
                        },
                        {
                            "role": "user", 
                            "content": f"""Contexto de manuales:
                            {context[:12000]}  # Limitar tama√±o por tokens
                            
                            Consulta del cliente: {query}
                            
                            Por favor responde de manera √∫til y completa:"""
                        }
                    ],
                    temperature=0.3,
                    max_tokens=800
                )
                
                answer = response.choices[0].message.content.strip()
                log.info("‚úÖ Respuesta generada con GPT")
                return answer
                
            except Exception as e:
                log.error(f"‚ùå Error con GPT: {str(e)}")
                # Fallback a respuesta manual
                return self._get_fallback_answer(query)
        else:
            # Fallback sin GPT
            return self._get_fallback_answer(query)
    
    def _get_fallback_answer(self, query: str) -> str:
        """Respuesta de fallback cuando GPT no est√° disponible"""
        query_lower = query.lower()
        
        if any(term in query_lower for term in ["diferencia", "amplia", "limitada"]):
            return """üöó *Diferencia entre P√≥lizas*

üìã *P√ìLIZA AMPLIA:*
‚Ä¢ ‚úÖ Da√±os a tu auto por accidente
‚Ä¢ ‚úÖ Robo total del veh√≠culo  
‚Ä¢ ‚úÖ Responsabilidad civil a terceros
‚Ä¢ ‚úÖ Gastos m√©dicos a ocupantes
‚Ä¢ ‚úÖ Asistencia vial 24/7
‚Ä¢ ‚úÖ Cristales y espejos

üìã *P√ìLIZA LIMITADA:*
‚Ä¢ ‚úÖ Responsabilidad civil a terceros
‚Ä¢ ‚úÖ Gastos m√©dicos a ocupantes
‚Ä¢ ‚ùå NO cubre da√±os a tu auto
‚Ä¢ ‚ùå NO cubre robo

üí° *La diferencia principal:* La p√≥liza amplia protege tu auto, la limitada solo protege a terceros.

¬øTe gustar√≠a conocer m√°s detalles o proceder con cotizaci√≥n?"""
        
        elif "amplia plus" in query_lower:
            return """üåü *P√ìLIZA AMPLIA PLUS* - Cobertura Premium

Incluye TODO de la p√≥liza amplia M√ÅS:

‚ú® *Beneficios exclusivos:*
‚Ä¢ üöô Auto sustituto por 15 d√≠as
‚Ä¢ üåé Cobertura en USA y Canad√°
‚Ä¢ üí∞ Deducible $0 en primer incidente
‚Ä¢ üè® Asistencia VIP en viajes
‚Ä¢ üîß Mantenimiento preventivo
‚Ä¢ üì± App exclusiva de servicios

üíé *Ideal para:* Quienes buscan m√°xima protecci√≥n y beneficios adicionales.

¬øTe interesa conocer el costo de esta cobertura?"""
        
        elif any(term in query_lower for term in ["qu√© incluye", "que incluye", "cubre"]):
            return """üìÑ *Coberturas Principales:*

üõ°Ô∏è *Protecci√≥n a Tu Auto:*
‚Ä¢ Colisi√≥n y vuelco
‚Ä¢ Incendio y explosi√≥n
‚Ä¢ Robo total o parcial
‚Ä¢ Da√±os por fen√≥menos naturales

üë• *Protecci√≥n a Terceros:*
‚Ä¢ Responsabilidad civil
‚Ä¢ Gastos m√©dicos
‚Ä¢ Da√±os materiales

üÜò *Asistencias:*
‚Ä¢ Gr√∫a y auxilio vial
‚Ä¢ M√©dica y legal
‚Ä¢ Veh√≠culo sustituto

¬øSobre qu√© cobertura espec√≠fica te gustar√≠a saber m√°s?"""
        
        else:
            return """ü§î No encontr√© informaci√≥n espec√≠fica sobre tu consulta en los manuales.

üí° *Puedo ayudarte con:*
‚Ä¢ Diferencias entre p√≥lizas
‚Ä¢ Coberturas espec√≠ficas  
‚Ä¢ Cotizaci√≥n de seguro
‚Ä¢ Documentaci√≥n requerida

¬øEn qu√© m√°s te puedo asistir?"""

# Instancia global del sistema RAG
rag_system = DriveRAGSystem()

# ==========================
# WhatsApp Functions
# ==========================
def send_message(to: str, text: str) -> bool:
    """Env√≠a mensaje por WhatsApp"""
    if not META_TOKEN or not WABA_PHONE_ID:
        log.error("‚ùå Configuraci√≥n de WhatsApp incompleta")
        return False
    
    url = f"https://graph.facebook.com/v20.0/{WABA_PHONE_ID}/messages"
    
    payload = {
        "messaging_product": "whatsapp",
        "to": to,
        "type": "text",
        "text": {"body": text}
    }
    
    headers = {
        "Authorization": f"Bearer {META_TOKEN}",
        "Content-Type": "application/json"
    }
    
    try:
        response = requests.post(url, json=payload, headers=headers, timeout=10)
        if response.status_code == 200:
            log.info(f"‚úÖ Mensaje enviado a {to}")
            return True
        else:
            log.error(f"‚ùå Error enviando mensaje: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        log.error(f"‚ùå Exception enviando mensaje: {str(e)}")
        return False

# ==========================
# Menu System
# ==========================
MAIN_MENU = """üü¶ *Vicky Bot ‚Äî Inbursa*

Elige una opci√≥n:

1) Pr√©stamo IMSS (Ley 73)
2) Seguro de Auto (cotizaci√≥n)  
3) Seguros de Vida / Salud
4) Tarjeta m√©dica VRIM
5) Cr√©dito Empresarial
6) Financiamiento Pr√°ctico
7) Contactar con Christian

Escribe el n√∫mero u opci√≥n (ej. 'imss', 'auto', 'empresarial')."""

def send_main_menu(phone: str):
    """Env√≠a el men√∫ principal"""
    send_message(phone, MAIN_MENU)

# ==========================
# Command Router - MEJORADO
# ==========================
def handle_auto_flow(phone: str, text: str):
    """Maneja el flujo de seguro de auto"""
    current_state = user_state.get(phone, "")
    
    if current_state == "":
        # Primer mensaje en flujo auto
        user_state[phone] = "auto_started"
        response = """üöó *Seguro de Auto*

Puedo ayudarte con:

‚Ä¢ üìã Informaci√≥n de coberturas
‚Ä¢ üîç Diferencias entre p√≥lizas  
‚Ä¢ üí∞ Cotizaci√≥n personalizada
‚Ä¢ üìÑ Documentaci√≥n requerida

*Puedes preguntar cosas como:*
‚Ä¢ "¬øQu√© diferencia hay entre amplia y limitada?"
‚Ä¢ "¬øQu√© cubre la p√≥liza amplia plus?"
‚Ä¢ "Quiero cotizar mi seguro"
‚Ä¢ "¬øQu√© documentos necesito?"

¬øEn qu√© te puedo ayudar?"""
        send_message(phone, response)
        
    elif current_state == "auto_started":
        # Procesar consulta del usuario
        if any(term in text.lower() for term in ["cotizar", "cotizaci√≥n", "precio", "cuesta"]):
            user_state[phone] = "awaiting_docs"
            response = """üìã *Proceso de Cotizaci√≥n*

Para generar tu cotizaci√≥n necesito:

üìÑ *Documentos requeridos:*
‚Ä¢ INE (identificaci√≥n oficial)
‚Ä¢ Tarjeta de circulaci√≥n 
‚Ä¢ O n√∫mero de placas del veh√≠culo

üìù *Informaci√≥n del veh√≠culo:*
‚Ä¢ A√±o, marca, modelo
‚Ä¢ Uso (particular/comercial)

Puedes enviar los documentos cuando est√©s listo.

¬øTienes alguna pregunta antes de continuar?"""
            send_message(phone, response)
            
        else:
            # Consulta informativa - usar RAG
            log.info(f"üîç Consulta RAG: {text}")
            response = rag_system.get_insurance_info(text)
            send_message(phone, response)
            
            # Ofrecer siguiente paso
            follow_up = "\n\n¬øTe gustar√≠a:\n‚Ä¢ M√°s informaci√≥n sobre otra cobertura\n‚Ä¢ Proceder con cotizaci√≥n\n‚Ä¢ Volver al men√∫ principal"
            send_message(phone, follow_up)
    
    elif current_state == "awaiting_docs":
        # Usuario envi√≥ documentos o informaci√≥n
        if any(term in text.lower() for term in ["s√≠", "si", "ok", "listo"]):
            response = """‚úÖ *Perfecto - Procesando tu solicitud*

He recibido tu informaci√≥n y documentos. 

üìû *Pr√≥ximos pasos:*
1. Revisar√© los datos de tu veh√≠culo
2. Generar√© cotizaci√≥n con mejores coberturas
3. Te contactar√© en m√°ximo 2 horas con opciones

Mientras tanto, ¬øtienes alguna otra pregunta?"""
            send_message(phone, response)
            user_state[phone] = "auto_started"  # Volver a estado anterior
            
        else:
            # Asumir que es informaci√≥n/documentos
            response = "‚úÖ Recibido. Estoy procesando tu informaci√≥n para la cotizaci√≥n. ¬øTienes alg√∫n documento m√°s o preguntas?"
            send_message(phone, response)

def route_command(phone: str, text: str):
    """Router principal de comandos"""
    text_lower = text.strip().lower()
    
    # Comandos principales
    if text_lower in ["1", "imss", "ley 73", "pr√©stamo imss"]:
        send_message(phone, "üè• *Pr√©stamo IMSS Ley 73* - Un asesor te contactar√° para explicarte los beneficios y requisitos.")
        send_main_menu(phone)
        
    elif text_lower in ["2", "auto", "seguro auto", "seguro de auto"]:
        handle_auto_flow(phone, text)
        
    elif text_lower in ["3", "vida", "salud", "seguro vida"]:
        send_message(phone, "üß¨ *Seguros de Vida/Salud* - Conect√°ndote con nuestro especialista...")
        send_main_menu(phone)
        
    elif text_lower in ["4", "vrim", "tarjeta m√©dica"]:
        send_message(phone, "ü©∫ *Tarjeta VRIM* - Te enviar√© informaci√≥n completa sobre la membres√≠a m√©dica.")
        send_main_menu(phone)
        
    elif text_lower in ["5", "empresarial", "cr√©dito empresarial"]:
        send_message(phone, "üè¢ *Cr√©dito Empresarial* - Un asesor se comunicar√° para evaluar tu empresa.")
        send_main_menu(phone)
        
    elif text_lower in ["6", "financiamiento", "pr√°ctico"]:
        send_message(phone, "üí∞ *Financiamiento Pr√°ctico* - Te contactaremos con opciones adaptadas a tus necesidades.")
        send_main_menu(phone)
        
    elif text_lower in ["7", "contactar", "christian", "asesor"]:
        send_message(phone, "üë®‚Äçüíº *Conectando con Christian* - Te atender√° personalmente en breve.")
        send_main_menu(phone)
        
    elif text_lower in ["menu", "men√∫", "volver", "inicio"]:
        user_state[phone] = ""
        send_main_menu(phone)
        
    else:
        # Si est√° en flujo de auto, manejar all√≠
        if user_state.get(phone, "").startswith("auto"):
            handle_auto_flow(phone, text)
        else:
            # Comando no reconocido
            send_message(phone, "‚ùì No entend√≠ tu mensaje. Escribe *men√∫* para ver las opciones disponibles.")
            send_main_menu(phone)

# ==========================
# Webhook Handlers
# ==========================
@app.route("/webhook", methods=["GET"])
def verify_webhook():
    """Verificaci√≥n del webhook"""
    mode = request.args.get("hub.mode")
    token = request.args.get("hub.verify_token")
    challenge = request.args.get("hub.challenge")
    
    if mode == "subscribe" and token == VERIFY_TOKEN:
        log.info("‚úÖ Webhook verificado")
        return challenge, 200
    else:
        log.error("‚ùå Verificaci√≥n de webhook fallida")
        return "Error", 403

@app.route("/webhook", methods=["POST"])
def handle_webhook():
    """Maneja mensajes entrantes"""
    try:
        data = request.get_json()
        log.info(f"üì• Webhook recibido: {json.dumps(data)[:500]}...")
        
        if not data:
            return jsonify({"status": "ok"}), 200
            
        # Procesar mensaje
        entry = data.get("entry", [{}])[0]
        changes = entry.get("changes", [{}])[0]
        value = changes.get("value", {})
        messages = value.get("messages", [])
        
        if not messages:
            return jsonify({"status": "ok"}), 200
            
        message = messages[0]
        phone = message.get("from")
        message_type = message.get("type")
        
        if message_type == "text":
            text = message.get("text", {}).get("body", "").strip()
            log.info(f"üí¨ Mensaje de {phone}: {text}")
            
            # Saludo inicial si es nuevo usuario
            if phone not in user_data:
                user_data[phone] = {"first_interaction": True}
                send_message(phone, "üëã ¬°Hola! Soy *Vicky*, tu asistente virtual de Inbursa. ¬øEn qu√© puedo ayudarte hoy?")
                time.sleep(1)
                send_main_menu(phone)
            else:
                # Procesar comando
                route_command(phone, text)
                
        elif message_type in ["image", "document"]:
            # Manejar archivos (documentos para cotizaci√≥n)
            log.info(f"üìé Archivo recibido de {phone}")
            send_message(phone, "‚úÖ Archivo recibido. Lo estoy procesando para tu cotizaci√≥n...")
            if user_state.get(phone) == "awaiting_docs":
                send_message(phone, "üìã Gracias por los documentos. Estoy generando tu cotizaci√≥n...")
                
        return jsonify({"status": "ok"}), 200
        
    except Exception as e:
        log.error(f"‚ùå Error en webhook: {str(e)}")
        return jsonify({"status": "error"}), 500

# ==========================
# Health Check & Admin
# ==========================
@app.route("/health", methods=["GET"])
def health_check():
    """Endpoint de salud"""
    drive_status = rag_system.drive_service is not None
    openai_status = rag_system.openai_client is not None
    
    return jsonify({
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "drive_connected": drive_status,
        "openai_connected": openai_status,
        "users_active": len(user_data)
    }), 200

@app.route("/admin/reload-manuals", methods=["POST"])
def reload_manuals():
    """Recargar manuales manualmente"""
    try:
        success = rag_system.load_manuals_from_drive()
        return jsonify({
            "success": success,
            "message": "Manuales recargados" if success else "Error recargando manuales"
        }), 200
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

# ==========================
# Inicializaci√≥n
# ==========================
def initialize_system():
    """Inicializa el sistema en segundo plano"""
    def init():
        time.sleep(5)  # Esperar que Flask est√© listo
        log.info("üöÄ Inicializando sistema...")
        
        # Cargar manuales
        rag_system.load_manuals_from_drive()
        
        log.info("‚úÖ Sistema inicializado")
    
    thread = threading.Thread(target=init, daemon=True)
    thread.start()

if __name__ == "__main__":
    log.info("üöÄ Iniciando Vicky SECOM Bot...")
    log.info(f"üìû WhatsApp: {'‚úÖ' if META_TOKEN and WABA_PHONE_ID else '‚ùå'}")
    log.info(f"üìä Google Drive: {'‚úÖ' if GOOGLE_CREDENTIALS_JSON else '‚ùå'}")
    log.info(f"üß† OpenAI: {'‚úÖ' if OPENAI_API_KEY else '‚ùå'}")
    
    initialize_system()
    
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=False)

